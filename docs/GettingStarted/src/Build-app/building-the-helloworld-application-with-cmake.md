## Building the HelloWorld! application with CMake

In the previous sections, building the _Hello_ _World!_ example is done by default during the Cyclone build process. However, the _Hello_ _World!_ example can also be build using the [CMake tool](http://cmake.org/), although you can obviously build with your native compilers and preferred toolchains.

[CMake](http://cmake.org/) is an open-source, cross-platform family of tools designed to build, test, and package software. It is used to control the software compilation process using simple platform and compiler independent configuration files, and generate native makefiles, projects, and workspaces of your development environment. CMake's main strength is build portability. The same CMake input files will build with GNU make, Visual studio 6,7,8 IDEs, Borland make, nmake, and XCode, etc...

Another advantage of CMake is building out-of-source. It simply works out-of-the-box. There are two important reasons to choose this:

- Easy cleanup (no cluttering the source tree). Simply remove the build directory if you want to start from scratch.
- Multiple build targets. It's possible to have up-to-date Debug and Release targets, without having to recompile the entire tree. For systems that do cross-platform compilation, it is easy to have up-to-date builds for the host and targetplatform.

There are a few other benefits to CMake, but that is out of the scope of this document.

In order to use CMake you need to provide a CMakeLists.txt. A sample CMakeList file can be found at `<install-location>/share/CycloneDDS/examples/helloworld/`

The content of the CMakeLists.txt is illustrated below:

```
cmake_minimum_required(VERSION 3.5)

if (NOT TARGET CycloneDDS::ddsc)
    # Find the CycloneDDS package. If it is not in a default location, try
    # finding it relative to the example where it most likely resides.
    find_package(CycloneDDS REQUIRED PATHS 
"${CMAKE_SOURCE_DIR}/../../") 
endif()

# This is a convenience function, provided by the CycloneDDS package,
# that will supply a library target related the the given idl file.
# In short, it takes the idl file, generates the source files with
# the proper data types and compiles them into a library.
idlc_generate(HelloWorldData_lib "HelloWorldData.idl")

# Both executables have only one related source file. 
add_executable(HelloworldPublisher publisher.c) 
add_executable(HelloworldSubscriber subscriber.c)

# Both executables need to be linked to the idl data type library and
# the ddsc API library.
target_link_libraries(HelloworldPublisher HelloWorldData_lib CycloneDDS::ddsc) 
target_link_libraries(HelloworldSubscriber HelloWorldData_lib CycloneDDS::ddsc)
```

To build a Cyclone based application you need to link your business code with:

1) the `ddsc` library that contains the DDS API that the application needs.

2) the helper functions and structures that represent your datatypes. These helpers are generated by the Cyclone pre-compiler IDL can be accessed through the CMake (`idlc_generate`) call that takes as input the idl file (e.g `HelloWorld.idl`) and package the datatyped helpers in a library (e.g `HelloWorldData_lib`).

The `idlc_generate` call makes use of the DDS IDLC-compiler how generated the helpers' functions and structures.

This process is depicted in the process below:

<div align=center> <img src="figs/2.2-1.png"></div>

The cyclone-based application executable (e.g `HelloworldPublisher`) will be built with the Cmake `target_link_libraries()` call. This call combines the `ddsc` lib, the datatype helper lib, and the application code lib.

Note that CMake will try to find the `CycloneDDS` CMake package in the default location, two levels above the current source directory. Every path and dependencies will be automatically set. CMake will look in the default locations for the code Cyclone DDS package.